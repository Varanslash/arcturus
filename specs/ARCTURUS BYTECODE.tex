\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{enumitem}

% Define colors for code
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Configure listings
\lstdefinestyle{bytecode}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue}\bfseries,
    numberstyle=\tiny\color{codegray},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=bytecode}

\title{\textbf{Arcturus to Bytecode Specification}}
\author{}
\date{}

\begin{document}

\maketitle

\section{Arithmetic Operations}

\subsection{\texttt{=} (assign)}
\begin{lstlisting}
PUSH <value>
STORE <variable>
\end{lstlisting}

\subsection{\texttt{+=} (addassign)}
\begin{lstlisting}
PUSH <number>
; this will be done for however many values are on the other side
; ex: x = 6 + 5, push 6, push 5
; ex: x += 6, same as x = x + 6, so push x, push 6
ADD <x>  ; pop x values deep and add together, auto push
STORE <dest>
\end{lstlisting}

\subsection{\texttt{-=} (subassign)}
\begin{lstlisting}
PUSH <number>  ; same as addassign
; ex: x = 6 - 5, push 6, push 5
; ex: x -= 6, same as x = x - 6, so push x, push 6
SUB <x>  ; pop x values deep and subtract all
STORE <dest>
\end{lstlisting}

\subsection{\texttt{*=} (mulassign)}
\begin{lstlisting}
PUSH <number>  ; same as addassign
MUL <x>  ; pop x values deep and multiply all
STORE <dest>
\end{lstlisting}

\subsection{\texttt{/=} (divassign)}
\begin{lstlisting}
PUSH <number>
DIV <x>
STORE <dest>
\end{lstlisting}

\subsection{Non-Assign Operations}
All of these are the same as the assign variants, except they don't load onto the stack unless manually assigned via \texttt{=}. They can also be used in comparisons.

\begin{itemize}[leftmargin=2cm]
    \item[\texttt{+}] add
    \item[\texttt{-}] sub
    \item[\texttt{*}] mul
    \item[\texttt{/}] div
\end{itemize}

\subsection{Bit Shifting}

\subsubsection{\texttt{>>} (bsr - bit shift right)}
\texttt{x >>} is the same as \texttt{x *= 2}

\subsubsection{\texttt{<<} (bsl - bit shift left)}
\texttt{x <<} is the same as \texttt{x /= 2}

\section{Comparison Operations}

Most comparison operations follow the same pattern -- we can use a single system:

\begin{lstlisting}
PUSH <left value>
PUSH <right value>
COMPARE <cmp>  ; auto pushes true or false
\end{lstlisting}

\end{document}

\section{Conditional Operations}

\subsection{\texttt{if} statements}

An \texttt{if} statement checks its condition and returns \texttt{true} or \texttt{false} onto the stack. If \texttt{true}, it jumps to the specified label; otherwise, it increments the instruction pointer.

\subsubsection{Example: \texttt{if x > 5 jump somewhere}}
\begin{lstlisting}
LOAD x
PUSH_INT 5
COMPARE GT        ; pops x and 5, pushes true/false
JUMP_IF somewhere ; pops boolean, jumps if true, else ip++
\end{lstlisting}

\subsubsection{Example: \texttt{if-else} pattern}
\begin{lstlisting}
; if x > 5:
LOAD x
PUSH_INT 5
COMPARE GT
JUMP_IF then_branch

; else code here
; ...
JUMP end_if

LABEL then_branch
; if code here
; ...
LABEL end_then

LABEL end_if
\end{lstlisting}

\end{document}
